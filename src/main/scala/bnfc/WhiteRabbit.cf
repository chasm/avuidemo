-- -*- mode: Haskell;-*- 
-- Filename:    rlambda.cf 
-- Authors:     lgm                                                    
-- Creation:    Fri May  1 13:17:06 2009 
-- Copyright:   Not supplied 
-- Description: 
--
-- Martin Odersky describes a challenge given by Corky M. :
--
-- Here's the language to to interpret (where postfix * means tupling):

-- Variables: x
-- Integer literals: i
-- Terms:

-- t = Lambda x*. t
--  |  Apply t t*
--  |  Var(x)
--  |  Num(i)

-- We assume usual operational semantics of lambda calculus (i.e. static scoping).

-- The task is to write two interpreters, one with variables x being
-- DeBruijn indices and one with them being names.
-- You should go for maximal sharing, i.e. factor out commonalities into
-- a common class/typeclass/functor/whatever, so that there remains no
-- duplication of code in the two solutions.
--
-- ------------------------------------------------------------------------

Sequence        . Expression    ::= Expression Expression1                ;
Application     . Expression1   ::= Expression1 Expression2               ;
Mention         . Expression2   ::= VariableExpr                          ;
Value           . Expression2   ::= ValueExpr                             ;
Abstraction     . Expression2   ::= "(" [VariableExpr] ")" "=>" Expression2 ;
Stipulation     . Expression2   ::= "val" VariableExpr "=" Expression2    ;

_               . Expression    ::= Expression1                           ;     
_               . Expression1   ::= Expression2                           ;
_               . Expression2   ::= "(" Expression ")"                    ;

Transcription   . VariableExpr  ::= "@" "<" Expression1 ">"               ;
AtomLiteral     . VariableExpr  ::= Ident                                 ;

Numeric         . ValueExpr     ::= Integer                               ;

[]              . [VariableExpr] ::=                                      ;
(: [])          . [VariableExpr] ::= VariableExpr                         ;
(:)             . [VariableExpr] ::= VariableExpr "," [VariableExpr]      ;

comment "//" ;
comment "/*" "*/" ;
