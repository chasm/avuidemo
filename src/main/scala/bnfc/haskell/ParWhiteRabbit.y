-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParWhiteRabbit where
import AbsWhiteRabbit
import LexWhiteRabbit
import ErrM
}

%name pExpression Expression
%name pExpression1 Expression1
%name pExpression2 Expression2
%name pVariableExpr VariableExpr
%name pValueExpr ValueExpr
%name pListVariableExpr ListVariableExpr

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 '=>' { PT _ (TS "=>") }
 '=' { PT _ (TS "=") }
 '@' { PT _ (TS "@") }
 '<' { PT _ (TS "<") }
 '>' { PT _ (TS ">") }
 ',' { PT _ (TS ",") }
 'val' { PT _ (TS "val") }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read $1) :: Integer }

Expression :: { Expression }
Expression : Expression Expression1 { Sequence $1 $2 } 
  | Expression1 { $1 }


Expression1 :: { Expression }
Expression1 : Expression1 Expression2 { Application $1 $2 } 
  | Expression2 { $1 }


Expression2 :: { Expression }
Expression2 : VariableExpr { Mention $1 } 
  | ValueExpr { Value $1 }
  | '(' ListVariableExpr ')' '=>' Expression2 { Abstraction $2 $5 }
  | 'val' VariableExpr '=' Expression2 { Stipulation $2 $4 }
  | '(' Expression ')' { $2 }


VariableExpr :: { VariableExpr }
VariableExpr : '@' '<' Expression1 '>' { Transcription $3 } 
  | Ident { AtomLiteral $1 }


ValueExpr :: { ValueExpr }
ValueExpr : Integer { Numeric $1 } 


ListVariableExpr :: { [VariableExpr] }
ListVariableExpr : {- empty -} { [] } 
  | VariableExpr { (:[]) $1 }
  | VariableExpr ',' ListVariableExpr { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

